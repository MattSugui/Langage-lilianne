''' <summary>
''' The grammatical feature constants.
''' </summary>
Public Module GrammarFeatureConstants
    'Public Const Condition As String = "(?<LeftOperand>[0-9A-Za-z]+|"".+"")\s(?<Operator>=|\<\>|\<|\>|\<=|\>=|Is|IsNot|Or|Or)\s(?<RightOperand>[0-9A-Za-z]+|"".+"")"
    REM Mapping:
    ' 0 to 12: Coco statements as added in October 2021
    ' 13: uhh i don't know
    ' 14: Test for Lilian intercoms (the same as a string version of feature 8 "Print ""|0-9|Identifier"). It creates a "print" statement and sends it to Lilian.
    ' 15: Schema

    ''' <summary>
    ''' The grammatical feature constants.
    ''' </summary>
    Public ReadOnly FeatureConstants As String() =
    {
        "^\s*Define\s(?<SymbolLiteral>.+)\s*$",
        "^\s*Create\s(?<SymbolLiteral>.+)\s*$",
        "^\s*If\s(?<LeftOperand>[0-9A-Za-z]+|"".+"")\s(?<Operator>=|\<\>|\<|\>|\<=|\>=|Is|IsNot|AndAlso|OrElse|SoundsLike)\s(?<RightOperand>[0-9A-Za-z]+|"".+"")\s*$",
        "^\s*ElseIf\s(?<LeftOperand>[0-9A-Za-z]+|"".+"")\s(?<Operator>=|\<\>|\<|\>|\<=|\>=|Is|IsNot|AndAlso|OrElse|SoundsLike)\s(?<RightOperand>[0-9A-Za-z]+|"".+"")\s*$",
        "^\s*(?<LeftOperand>[0-9A-Za-z]+|"".+"")\s(?<Operator>=|(?:\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>)=)\s(?<RightOperand>[0-9A-Za-z]+|"".+""|(?<InnerLeft>[0-9A-Za-z]+|"".+"")\s(?<InnerOperator>\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>|And|Or|Xor|Is|IsNot|AndAlso|OrElse|SoundsLike)\s(?<InnerRight>[0-9A-Za-z]+|"".+""))\s*$",
        "^\s*Option\s(?<Setting>)\s*$",
        "^\s*End(?<CurrentMode>(?:\s)[A-Za-z]+)?\s*$",
        "^\s*Exit\s*$",
        "^\s*Print\s(?<Value>[0-9A-Za-z]+|(?<InnerLeft>[0-9A-Za-z]+|"".+"")\s(?<InnerOperator>\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>|And|Or|Xor|Is|IsNot|AndAlso|OrElse|SoundsLike)\s(?<InnerRight>[0-9A-Za-z]+|"".+""))\s*$",
        "^\s*Version\s(?<MajorVersion>[0-9]+).(?<MinorVersion>[0-9]+)\s*$",
        "^\s*'.*\s*$",
        "^\s*Run\s*$",
        "^\s*Destroy\s(?<LeftOperand>[0-9A-Za-z]+)\s*$",
        "^\s*Statement\s(?<Name>[0-9A-Za-z]*)\s*$",
        "^\s*Write\s(?<Value>"".*"")",
        "\s*Token\s(?<Name>[^\s]+)\s*$"
    }
End Module
Imports System
Imports System.Collections.Generic
Imports System.Linq
Imports System.Text
Imports System.Text.RegularExpressions
Imports System.Threading
Imports System.Threading.Tasks
Imports System.Reflection
Imports System.IO
Imports System.IO.MemoryMappedFiles
Imports System.Diagnostics

Public Module Cooperation
    Public Sub Handshake()
        Try
            Using Commons As MemoryMappedFile = MemoryMappedFile.OpenExisting("lilycoco")
                Dim mutex1 As Mutex = Mutex.OpenExisting("lilmutex")
                mutex1.WaitOne()

                Using stream As MemoryMappedViewStream = Commons.CreateViewStream(1, 0)
                    Console.WriteLine("Oh, hello, Lilian! I'm Coco!")
                    Dim pen As New BinaryWriter(stream)
                    pen.Write(True)
                End Using
                mutex1.ReleaseMutex()
            End Using
        Catch ex As Exception
            Throw New Lamentation(3, ex.Message)
        End Try
    End Sub

    Public Sub Deal()
        Try
            Using stream As FileStream = File.OpenWrite("lilycoco.tmp")
                Using glass As New BinaryReader(stream)
                    Dim VibeCheck As String = glass.ReadString()
                    If VibeCheck = "Hey, Coco! Are you there?" Then
                        Using pen As New BinaryWriter(stream)
                            pen.Write("Yes! I'm here, bitch!")
                            Console.WriteLine("COCO: Yes! I'm here, bitch!")
                        End Using
                    End If
                End Using
            End Using
        Catch ex As Exception
            Throw New Lamentation(3, ex.Message)
        End Try
    End Sub
End Module
'Option Compare Text ' useless since regex aint insensitive bru8h

#Const ContextualisationTesting = True

Imports System.Text
Imports System.Text.RegularExpressions
Imports System.Collections.Generic
Imports System.IO
Imports System.Linq

''' <summary>
''' The main class for the interpeter.
''' </summary>
Partial Public Module Interpreter
    'Public CurrentLine As String
    ''' <summary>
    ''' Unused
    ''' </summary>
    Public CurrentRow As Integer

    ''' <summary>
    ''' Unused
    ''' </summary>
    Public CurrentColumn As Integer

    ''' <summary>
    ''' The current consummate file. This is a combination of all source files loaded into Coco.
    ''' </summary>
    Public CurrentFile As String

    ''' <summary>
    ''' The current consummate file.
    ''' </summary>
    Public CurrentSource As New List(Of String)

    ''' <summary>
    ''' The currently-collected list of compiler errors to regurgitate all at once after compilation.
    ''' </summary>
    Public CompilerErrors As New List(Of Lamentation)

    ''' <summary>
    ''' The main container of instructions.
    ''' </summary>
    Public MotherContext As New Context()

    ''' <summary>
    ''' The main stack.
    ''' </summary>
    Public MotherStack As New List(Of FELObject)

    ''' <summary>
    ''' Unused
    ''' </summary>
    Public TempStack As New Queue(Of FELObject)

    'Public Sub InterpretThread(LineCollection As String)
    '    Dim Collection As New List(Of String)

    '    'If Not LineCollection.Contains(";") Then Throw New Lamentation("no semicolon??", 420)

    '    For Each Item As String In LineCollection.Split(vbCrLf)
    '        Collection.Add(Item)
    '    Next

    '    CurrentRow = 0
    '    CurrentLine = Collection(CurrentRow)

    '    Do
    '        Interpret()
    '        CurrentRow += 1
    '        CurrentLine = If(CurrentRow <> Collection.Count, Collection(CurrentRow), Nothing)
    '    Loop Until CurrentLine Is Nothing
    'End Sub

    ''' <summary>
    ''' Loads a file and adds it to the consummate file.
    ''' </summary>
    ''' <param name="path">The path to the source file.</param>
    ''' <param name="zoom">If true, don't display the "Press any key to continue" notice. Used for when Lilian calls this program.</param>
    Public Sub LoadFile(path As String)
        If File.Exists(path) Then
            If Not Zoom Then EnableIncrementalContextualisation = True
            Dim doccy = File.ReadAllLines(path)
            For document As Integer = 0 To doccy.Length - 1
                Try
                    Interpret(doccy(document))
                    If Not Zoom Then
                        Console.WriteLine($"Parsing {document + 1} out of {doccy.Length}.")
                        Console.SetCursorPosition(0, Console.CursorTop - 1) ' comment after debug
                    Else Continue For : End If
                Catch cry As Lamentation
                    'Console.WriteLine($"{cry.ErrorCode}: {cry.Message}")
                    CompilerErrors.Add(cry)
                    Continue For
                Catch ex As Exception
                    Console.WriteLine($"1000: Internal compiler error. {ex.GetType}; {ex.Message}")
                    Exit Sub
                End Try
            Next
            If CompilerErrors.Count > 0 OrElse CompilerErrors.Count <> 0 Then Exit Sub ' gtfo
            If Not Zoom Then Console.WriteLine("Interpretation complete" & vbCrLf & "####################")
            Curse(MotherContext)
            If Not Zoom Then
                Console.WriteLine("####################" & vbCrLf & "End of execution. Press any key to exit.")
                Console.ReadKey()
            Else
                Console.WriteLine("End of preprocessing. Over to you, Lilian!")
            End If

            End
        Else
            Console.WriteLine("This file does not exist.")
            End
        End If
    End Sub

    ''' <summary>
    ''' Reads from a path.
    ''' </summary>
    ''' <param name="path">The path to the file.</param>
    Public Sub ReadFile(path As String)
        If File.Exists(path.Trim("""")) Then
            For Each line As String In File.ReadAllLines(path.Trim(""""))
                CurrentSource.Add(line)
            Next
        Else
            Throw New Lamentation(2, path.Trim(""""))
        End If
    End Sub

    Public Sub ReadDirect(thing As String())
        For Each line As String In thing
            CurrentSource.Add(line)
        Next
    End Sub

    ''' <summary>
    ''' The primary interpretation session.
    ''' </summary>
    ''' <param name="Line">One of the lines of the consummate text.</param>
    Public Sub Interpret(Line As String)
        Dim DataCollection As New List(Of String)

        Dim act As New Action(0)
        Dim obj As New FELObject()

        'Dim Quotation As Boolean

        'For Each Item As String In LineCollection
        If Not String.IsNullOrEmpty(Line) OrElse Not String.IsNullOrWhiteSpace(Line) Then
            For Each Feature As String In FeatureConstants
                If Regex.IsMatch(Line, Feature) Then
                    Select Case Array.IndexOf(FeatureConstants, Feature)
                        Case 0
                            'act = New Action(3, Regex.Match(Line, "^\s*Define\s(?<SymbolLiteral>.+)\s*$").Groups("SymbolLiteral").Value)

                            obj = New FELObject(Regex.Match(Line, "^\s*Define\s(?<SymbolLiteral>.+)\s*$").Groups("SymbolLiteral").Value)
                            MotherStack.Add(obj)
                        Case 1 To 3
                            Console.WriteLine("hey!")
                        Case 4
                            If Regex.IsMatch(Line, "^\s*(?<LeftOperand>[0-9A-Za-z]+|"".+"")\s(?<Operator>=|(?:\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>)=)\s(?<InnerLeft>[0-9A-Za-z]+|"".+"")\s(?<InnerOperator>\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>|And|Or|Xor|Is|IsNot|AndAlso|OrElse|SoundsLike)\s(?<InnerRight>[0-9A-Za-z]+|"".+"")\s*$") Then
                                Dim cont = Regex.Match(Line, "^\s*(?<LeftOperand>[0-9A-Za-z]+|"".+"")\s(?<Operator>=|(?:\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>)=)\s(?<InnerLeft>[0-9A-Za-z]+|"".+"")\s(?<InnerOperator>\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>|And|Or|Xor|Is|IsNot|AndAlso|OrElse|SoundsLike)\s(?<InnerRight>[0-9A-Za-z]+|"".+"")\s*$")
                                ManipulationTime(cont, act)
                            ElseIf Regex.IsMatch(Line, "^\s*(?<LeftOperand>[0-9A-Za-z]+|"".+"")\s(?<Operator>=|(?:\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>)=)\s(?<InnerLeft>[0-9A-Za-z]+|"".*"")\s*$") Then
                                Dim cont = Regex.Match(Line, "^\s*(?<LeftOperand>[0-9A-Za-z]+|"".+"")\s(?<Operator>=|(?:\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>)=)\s(?<InnerLeft>[0-9A-Za-z]+|"".*"")\s*$")
                                ManipulationTime(cont, act)
                            End If
                        Case 7
                            End
                        Case 8
#If Not ContextualisationTesting Then
                            If Regex.IsMatch(Line, "^\s*Print\s(?<Value>[0-9A-Za-z]+)\s*$") Then
                                Dim Number As Long
                                If Long.TryParse(Regex.Match(Line, "^\s*Print\s(?<Value>[0-9]+)\s*$").Groups("Value").Value, Number) Then
                                    act = New Action(1, Number)
                                Else
                                    Dim oop = Regex.Match(Line, "^\s*Print\s(?<Value>[0-9A-Za-z]+)\s*$")
                                    If MotherStack.Exists(Function(thing As FELObject) thing.Name = oop.Groups("Value").Value) Then
                                        act = New Action(1, CType(MotherStack.Find(Function(thing As FELObject) thing.Name = oop.Groups("Value").Value), FELObject).Value)
                                    Else Throw New Lamentation("bruh111234", 111234)
                                    End If
                                End If
                            ElseIf Regex.IsMatch(Line, "^\s*Print\s(?<LeftOperand>[0-9A-Za-z]+|"".+"")\s(?<Operator>=|\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>|\<\>|\<|\>|\<=|\>=|Is|IsNot|Or|Or|Xor|IsLike)\s(?<RightOperand>[0-9A-Za-z]+|"".+"")\s*$") Then
                                Dim thing = Regex.Match(Line, "^\s*Print\s(?<LeftOperand>[0-9]+)\s(?<Operator>=|\+|-|\*|\/|%|&|`|^|~|\\|\$|<<|>>|\<\>|\<|\>|\<=|\>=|Is|IsNot|Or|Or|Xor|IsLike)\s(?<RightOperand>[0-9]+)\s*$")
                                Dim Number1, Number2 As Long
                                If Long.TryParse(thing.Groups("LeftOperand").Value, Number1) AndAlso Long.TryParse(thing.Groups("RightOperand").Value, Number2) Then
                                    Select Case thing.Groups("Operator").Value
                                        Case "+"
                                            act = New Action(1, Number1 + Number2)
                                        Case "-"
                                            act = New Action(1, Number1 - Number2)
                                        Case "*"
                                            act = New Action(1, Number1 * Number2)
                                        Case "/"
                                            act = New Action(1, Number1 / Number2)
                                        Case "`"
                                            act = New Action(1, CLng(Math.Pow(Number1, Number2)))
                                        Case "%"
                                            act = New Action(1, Number1 Mod Number2)
                                        Case "&", "Or"
                                            act = New Action(1, Number1 Or Number2)
                                        Case "|", "Or"
                                            act = New Action(1, Number1 Or Number2)
                                        Case "^\s*", "Xor"
                                            act = New Action(1, Number1 Xor Number2)
                                        Case "~"
                                            Throw New Lamentation("sorry, my bad")
                                        Case "$"
                                            act = New Action(1, Number1 & Number2)
                                        Case "<<"
                                            act = New Action(1, Number1 * 2 * Number2)
                                        Case ">>"
                                            act = New Action(1, Number1 / 2 * Number2)
                                        Case "<"
                                            act = New Action(1, Number1 < Number2)
                                        Case "<="
                                            act = New Action(1, Number1 <= Number2)
                                        Case ">"
                                            act = New Action(1, Number1 > Number2)
                                        Case ">="
                                            act = New Action(1, Number1 >= Number2)
                                        Case "<>"
                                            act = New Action(1, Number1 <> Number2)
                                        Case "=="
                                            act = New Action(1, Number1 = Number2)
                                        Case "Is", "IsNot", "IsLike"
                                            Throw New Lamentation("wrong", 2)
                                    End Select
                                ElseIf Regex.IsMatch(Line, "^\s*Print\s(?<LeftOperand>"".+"")\s(?<Operator>\$)\s(?<RightOperand>"".+"")\s*$") Then
                                    act = New Action(1, Regex.Match(Line, "^\s*Print\s(?<LeftOperand>"".+"")\s(?<Operator>\$)\s(?<RightOperand>"".+"")\s*$").Value.Trim("""") & Regex.Match(Line, "^\s*Print\s(?<LeftOperand>"".+"")\s(?<Operator>\$)\s(?<RightOperand>"".+"")\s*$").Groups("RightOperand").Value.Trim(""""))
                                End If
                            ElseIf Regex.IsMatch(Line, "^\s*Print\s(?<Value>"".*"")\s*$") Then
                                act = New Action(1, Regex.Match(Line, "^\s*Print\s(?<Value>"".*"")\s*$").Groups("Value").Value.Trim(""""))
                            End If
#Else
                            If MotherStack.Exists(Function(thing As FELObject) thing.Name = Regex.Match(Line, Feature).Groups("Value").ToString()) Then
                                act = New Action(1, MotherStack.Find(Function(thing As FELObject) thing.Name = Regex.Match(Line, Feature).Groups("Value").ToString()))
                            Else
                                If Regex.IsMatch(Line, "\s*Print\s(?<InnerLeft>[0-9A-Za-z]+|"".*"")\s(?<InnerOperator>\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>|And|Or|Xor|Is|IsNot|AndAlso|OrElse|SoundsLike)\s(?<InnerRight>[0-9A-Za-z]+|"".*"")\s*$") Then
                                    Dim cont = Regex.Match(Line, "\s*Print\s(?<InnerLeft>[0-9A-Za-z]+|"".*"")\s(?<InnerOperator>\+|-|\*|\/|%|&|`|^|!|~|\\|\$|<<|>>|And|Or|Xor|Is|IsNot|AndAlso|OrElse|SoundsLike)\s(?<InnerRight>[0-9A-Za-z]+|"".*"")\s*$")
                                    ManipulationTime(cont, act, False, True)
                                ElseIf Regex.IsMatch(Line, "^\s*Print\s(?<Value>[0-9]+|"".*"")\s*$") Then
                                    Dim cont = Regex.Match(Line, "^\s*Print\s(?<Value>[0-9]+|"".*"")\s*$")
                                    act = New Action(1, cont.Groups("Value").Value.Trim(""""c))
                                    'ManipulationTime(Nothing, cont.Groups("Value").Value, Nothing, act, Nothing, Nothing, False, True)
                                End If

                            End If
#End If
                        Case 9
                            'Console.WriteLine("not implemented yet!")
                            act = New Action(0)
                        Case 10
                            Exit Sub
                            ' is just a comment! like this one
                        Case 11
                            Curse(MotherContext)
                            Exit Sub
                        Case 13
                        Case 14
                            Manipulation(Regex.Match(Line, Feature).Groups("Value").Value)
                        Case 15 To 20

                        Case Else
                            Console.WriteLine("hey!")
                    End Select
                    Exit For
                Else
                    If Array.IndexOf(FeatureConstants, Feature) <> FeatureConstants.Length - 1 Then Continue For Else Throw New Lamentation(1, Line)
                End If
            Next
        Else GoTo Finished
        End If
        'Next


Finished:
        If EnableIncrementalContextualisation Then
            MotherContext.Append(act)
        ElseIf EmittedStatements.Count <> 0 Then
            ProposeMods()
        Else
            Curse(act)
        End If
    End Sub

    ''' <summary>
    ''' How the interpreter puts two and two together.
    ''' </summary>
    <Flags>
    Private Enum ManipulationType
        ''' <summary>
        ''' Doing nothing.
        ''' </summary>
        [Default] = 0

        ''' <summary>
        ''' Identifier to identifier.
        ''' </summary>
        NamedToNamed = 1

        ''' <summary>
        ''' Literal to identifier.
        ''' </summary>
        ValueToNamed = 2

        ''' <summary>
        ''' Operation to identifier.
        ''' </summary>
        OperationToNamed = 4

        ''' <summary>
        ''' Condition to identifier.
        ''' </summary>
        ConditionToNamed = 8


        ''' <summary>
        ''' String manipulation.
        ''' </summary>
        StringTo = 64

        ''' <summary>
        ''' Integral manipulation.
        ''' </summary>
        NumericalTo = 128

        ''' <summary>
        ''' Boolean manipulation.
        ''' </summary>
        BoolTo = 256


        ''' <summary>
        ''' The identifier is the left operand.
        ''' </summary>
        OnLeft = 512

        ''' <summary>
        ''' The identifier is the right operand.
        ''' </summary>
        OnRight = 1024
    End Enum

    ''' <summary>
    ''' Primary manipulation session.
    ''' </summary>
    ''' <param name="contenu">The match that has the values.</param>
    ''' <param name="activity">The action to be modified.</param>
    ''' <param name="onetime">If the manipulation is temporary.</param>
    ''' <param name="forprint">If the manipulation is for printing.</param>
    Private Sub ManipulationTime(contenu As Match, ByRef activity As Action, Optional onetime As Boolean = False, Optional forprint As Boolean = False)
        'On Error GoTo Oopsie

        Dim test, right, final, initial As Long
        Dim stest, sright, sfinal, sinitial As String
        Dim btest, bright, bfinal, binitial As Boolean
        Dim howto, useWhat As ManipulationType
        Dim TypeInference As Boolean
        Dim finalObj
        Dim ObjectToUse As FELObject

        test = 0 : right = 0 : final = 0 : initial = 0
        stest = String.Empty : sright = String.Empty : sfinal = String.Empty : sinitial = String.Empty
        btest = False : bright = False : bfinal = False : binitial = False
        finalObj = Nothing

        Try
            If Not forprint Then
                If MotherStack.Exists(Function(thing As FELObject) thing.Name = contenu.Groups("LeftOperand").Value) Then
                    Dim printi As FELObject = MotherStack.Find(Function(thing As FELObject) thing.Name = contenu.Groups("LeftOperand").Value)
                    If TypeOf printi.Value Is Long Then
                        initial = printi.Value
                    ElseIf TypeOf printi.Value Is Boolean Then
                        binitial = printi.Value
                    ElseIf TypeOf printi.Value Is String Then
                        sinitial = printi.Value
                    Else
                        TypeInference = True
                    End If
                    ObjectToUse = printi
                End If
            End If

            If MotherStack.Exists(Function(thing As FELObject) thing.Name = contenu.Groups("InnerLeft").Value) Then
                Dim printi As FELObject = MotherStack.Find(Function(thing As FELObject) thing.Name = contenu.Groups("InnerLeft").Value)
                If TypeOf printi.Value Is Long Then
                    test = printi.Value
                    useWhat = ManipulationType.NumericalTo
                ElseIf TypeOf printi.Value Is Boolean Then
                    btest = printi.Value
                    useWhat = ManipulationType.BoolTo
                ElseIf TypeOf printi.Value Is String Then
                    stest = printi.Value
                    useWhat = ManipulationType.StringTo
                End If
            Else
                Dim bruh = contenu.Groups("InnerLeft").Value
                If Long.TryParse(bruh, test) Then
                    useWhat = ManipulationType.NumericalTo
                ElseIf Boolean.TryParse(bruh, btest) Then
                    useWhat = ManipulationType.BoolTo
                ElseIf Regex.IsMatch(bruh, """(?<Value>.*)""") Then
                    stest = Regex.Match(bruh, """(?<Value>.*)""").Groups("Value").Value
                    useWhat = ManipulationType.StringTo
                Else Throw New Lamentation("KJSDGUUDOFG", 2454)
                End If
            End If

            If Not String.IsNullOrEmpty(contenu.Groups("InnerRight").Value) Then
                If MotherStack.Exists(Function(thing As FELObject) thing.Name = contenu.Groups("InnerRight").Value) Then
                    Dim printii As FELObject = MotherStack.Find(Function(thing As FELObject) thing.Name = contenu.Groups("InnerRight").Value)
                    If TypeOf printii.Value Is Long Then
                        right = printii.Value
                        howto = ManipulationType.NumericalTo
                    ElseIf TypeOf printii.Value Is Boolean Then
                        bright = printii.Value
                        howto = ManipulationType.BoolTo
                    ElseIf TypeOf printii.Value Is String Then
                        sright = printii.Value
                        howto = ManipulationType.StringTo
                    End If
                Else
                    Dim bruh = contenu.Groups("InnerRight").Value
                    If Long.TryParse(bruh, right) Then
                        howto = ManipulationType.NumericalTo
                    ElseIf Boolean.TryParse(bruh, bright) Then
                        howto = ManipulationType.BoolTo
                    ElseIf Regex.IsMatch(bruh, """(?<Value>.*)""") Then
                        sright = Regex.Match(bruh, """(?<Value>.*)""").Groups("Value").Value
                        howto = ManipulationType.StringTo
                    ElseIf String.IsNullOrEmpty(bruh) Then
                    Else Throw New Lamentation("KJSDGUUDOFG", 2454)
                    End If
                End If
            End If
            If howto = 0 Then howto = useWhat
            If useWhat = 0 Then useWhat = howto ' recursive ???
            If Not String.IsNullOrEmpty(contenu.Groups("InnerOperator").Value) Then
                Select Case howto
                    Case ManipulationType.NumericalTo
                        Select Case contenu.Groups("InnerOperator").Value
                            Case "+"
                                final = test + right
                            Case "-"
                                final = test - right
                            Case "*"
                                final = test * right
                            Case "/"
                                final = test / right
                            Case "`"
                                final = Math.Pow(test, right)
                            Case "%"
                                final = test Mod right
                            Case "&", "And"
                                final = test And right
                            Case "|", "Or"
                                final = test Or right
                            Case "^", "Xor"
                                final = test Xor right
                            Case "$"
                                sfinal = test & right
                                useWhat = ManipulationType.StringTo
                            Case "<<"
                                final = test << right
                            Case ">>"
                                final = test >> right
                            Case "<"
                                bfinal = test < right
                                useWhat = ManipulationType.BoolTo
                            Case "<="
                                bfinal = test <= right
                                useWhat = ManipulationType.BoolTo
                            Case ">"
                                bfinal = test > right
                                useWhat = ManipulationType.BoolTo
                            Case ">="
                                bfinal = test >= right
                                useWhat = ManipulationType.BoolTo
                            Case "<>"
                                bfinal = test <> right
                                useWhat = ManipulationType.BoolTo
                            Case "="
                                bfinal = test = right
                                useWhat = ManipulationType.BoolTo
                            Case Else
                                Throw New Lamentation("wrong", 2)
                        End Select
                    Case ManipulationType.BoolTo
                        Select Case contenu.Groups("InnerOperator").Value
                            Case "&", "And", "AndAlso"
                                bfinal = btest And bright
                            Case "|", "Or", "OrElse"
                                bfinal = btest Or bright
                            Case "^", "Xor"
                                bfinal = btest Xor bright
                            Case "$"
                                sfinal = btest & bright
                                useWhat = ManipulationType.StringTo
                            Case Else
                                Throw New Lamentation("wrong", 2)
                        End Select
                    Case ManipulationType.StringTo
                        Select Case contenu.Groups("InnerOperator").Value
                            Case "$"
                                sfinal = stest & sright
                            Case "<>"
                                bfinal = stest <> sright
                                useWhat = ManipulationType.BoolTo
                            Case "="
                                bfinal = stest = sright
                                useWhat = ManipulationType.BoolTo
                            Case Else
                                Throw New Lamentation("wrong", 2)
                        End Select
                End Select
            Else
                Select Case howto
                    Case ManipulationType.BoolTo
                        bfinal = btest
                    Case ManipulationType.NumericalTo
                        final = test
                    Case ManipulationType.StringTo
                        sfinal = stest
                End Select
            End If

            If Not forprint Then
                If TypeInference Then

                End If
                Select Case howto
                    Case ManipulationType.NumericalTo
                        Select Case contenu.Groups("Operator").Value
                            Case "+="
                                initial += final
                            Case "-="
                                initial -= final
                            Case "*="
                                initial *= final
                            Case "/="
                                initial /= final
                            Case "`="
                                initial = Math.Pow(initial, final)
                            Case "%="
                                initial = initial Mod final
                            Case "&=" ', "And"
                                initial = initial And final
                            Case "|=" ', "Or"
                                initial = initial Or final
                            Case "^=" ', "Xor"
                                initial = initial Xor final
                            Case "$="
                                sinitial &= sfinal
                                useWhat = ManipulationType.StringTo
                            Case "<<="
                                initial <<= final
                            Case ">>="
                                initial >>= final
                            Case "="
                                initial = final
                            Case Else
                                Throw New Lamentation("wrong", 2)
                        End Select
                    Case ManipulationType.BoolTo
                        Select Case contenu.Groups("Operator").Value
                            Case "&=" ', "And", "AndAlso"
                                binitial = binitial And bfinal
                            Case "|=" ', "Or", "OrElse"
                                binitial = binitial Or bfinal
                            Case "^=" ', "Xor"
                                binitial = binitial Xor bfinal
                            Case "$="
                                sinitial &= bfinal
                                useWhat = ManipulationType.StringTo
                            Case "="
                                binitial = bfinal
                            Case Else
                                Throw New Lamentation("wrong", 2)
                        End Select
                    Case ManipulationType.StringTo
                        Select Case contenu.Groups("Operator").Value
                            Case "$="
                                sinitial &= sfinal
                            Case "="
                                sinitial = sfinal
                            Case Else
                                Throw New Lamentation("wrong", 2)
                        End Select

                End Select
            End If

            If forprint Then
                Select Case useWhat
                    Case ManipulationType.BoolTo : finalObj = bfinal
                    Case ManipulationType.NumericalTo : finalObj = final
                    Case ManipulationType.StringTo : finalObj = sfinal
                End Select
            Else
                Select Case useWhat
                    Case ManipulationType.BoolTo : finalObj = binitial
                    Case ManipulationType.NumericalTo : finalObj = initial
                    Case ManipulationType.StringTo : finalObj = sinitial
                End Select
            End If

            If forprint Then
                activity = New Action(1, finalObj)
            Else
                activity = New Action(2, ObjectToUse.Name, finalObj)
            End If

            'Exit Sub ' should i keep this
        Catch cry As Lamentation
            Throw
        Catch ex As Exception
            Throw New Lamentation("internal compiler error!", 1000)
        End Try
    End Sub

    ''' <summary>
    ''' Gets or sets whether Coco is running as a REPL or as a compiler.
    ''' </summary>
    ''' <returns></returns>
    Public Property EnableIncrementalContextualisation As Boolean = False

End Module
Imports System.IO
Imports System.Xml
Imports System.Xml.Schema
Imports System.Xml.Serialization

Partial Public Module Interpreter
    ' Manipulation time
    ''' <summary>
    ''' Turn a command into a Lilian instance or statement. For schemas, it is the job of the SchemaInterpreter file portion of the <see cref="Interpreter"/> module.
    ''' </summary>
    ''' <param name="text"></param>
    Public Sub Manipulation(text As String)
        EmittedStatements.Add($"print ""{text.Trim(""""c)}"";")
    End Sub

    Public EmittedStatements As New List(Of String)

    ''' <summary>
    ''' Write all proposed mods to disk.
    ''' </summary>
    Public Sub ProposeMods()
        Dim Unconverted As New List(Of ProposedMod)
        Try
            For Each line As String In EmittedStatements
                Unconverted.Add(New ProposedMod() With {.ProposedStatement = line, .WhatToDo = 1})
            Next

            Dim ReturningValue As Byte()

            Dim Formatter As New XmlSerializer(GetType(ProposedMod()))
            Dim Stream As New MemoryStream
            Formatter.Serialize(Stream, Unconverted.ToArray())
            'ReDim ReturningValue(Stream.ToArray().Length)
            ReturningValue = Stream.ToArray()

            Using Pen As New BinaryWriter(New FileStream("cocoadd.tmp", FileMode.Create))
                Pen.Write(ReturningValue.Length)
                Pen.Write(ReturningValue)
            End Using
        Catch e As Exception
            Throw New Lamentation(4, e.Message)
        End Try
    End Sub

    <Serializable> Public Class ProposedMod
        Public ProposedStatement As String
        Public WhatToDo As Integer
    End Class
End Module


Imports System
Imports System.Reflection
Imports System.IO

Public Module Program
    Public Zoom As Boolean = False
    Public Sub Main(args As String())
        If Not args.Contains("-nobanner") Then
            Console.WriteLine(
                "Fonder Lilian Language Coco Environment" & vbCrLf &
                "Version " & Assembly.GetExecutingAssembly().GetName().Version.ToString() + ", 2021" & vbCrLf)
        End If

        If args.Length > 0 Then
            If args(0) = "-p" Then
                Deal()
            ElseIf args(0) = "-d" Then
                If args.Length >= 2 AndAlso args(1).Length <> 0 Then

                Else
                    Console.WriteLine("You must supply a fragment or file!")
                    End
                End If
            ElseIf args(0) = "-l" Then
#If Not DEBUG Then
                Debug.WriteLine("With slash: " & File.Exists("\cocotmp.ccn"))
                Debug.WriteLine("Local: " & File.Exists("cocotmp.ccn"))
                Debug.WriteLine("With dot-slash: " & File.Exists("..\cocotmp.ccn"))
                Debug.WriteLine($"Environment {(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) & "\cocotmp.ccn")}): " & File.Exists(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) & "\cocotmp.ccn"))
                Console.ReadLine()
#End If

                If File.Exists("cocotmp.ccn") Then
                    Zoom = True : EnableIncrementalContextualisation = False
                    LoadFile("cocotmp.ccn")
                    If CompilerErrors.Count > 0 OrElse CompilerErrors.Count <> 0 Then GoTo CompilationErrorMessages
                Else
                    Console.WriteLine("Temp file does not exist. Belayed and backing off.")
                    Exit Sub
                End If
            Else
                Zoom = args.Length > 1 AndAlso args(1) = "-l"
                'Try
                LoadFile(args(0))
                'Else Throw New Lamentation("bruh!", 21)
                If CompilerErrors.Count > 0 OrElse CompilerErrors.Count <> 0 Then GoTo CompilationErrorMessages
            End If
        Else
            GoTo REPLMode
        End If

REPLMode:
        Console.WriteLine("Welcome to the REPL mode! Type EXIT if you've had your fun.")

        Console.WriteLine("This version is a test on contextualisation. Press Y to do incremental programming, or press N for classic REPL.")
        While True
            Dim kex = Console.ReadKey
            If kex.Key = ConsoleKey.Y Then
                EnableIncrementalContextualisation = True
                Exit While
            ElseIf kex.Key = ConsoleKey.N Then
                EnableIncrementalContextualisation = False
                Exit While
            Else
                Console.SetCursorPosition(0, Console.CursorTop)
                Continue While
            End If
        End While
        Console.WriteLine()


        While True
            Try
                Interpret(Console.ReadLine())
            Catch cry As Lamentation
                Console.WriteLine($"{cry.ErrorCode}: {cry.Message}")
            Catch ex As Exception
                Console.WriteLine($"1000: Internal compiler error. {ex}; {ex.Message}")
            End Try
        End While

CompilationErrorMessages:
        If Not Zoom Then
            Console.WriteLine($"{CompilerErrors.Count} compiler {If(CompilerErrors.Count > 1, "errors were", "error was")} found. Press Y to view {If(CompilerErrors.Count > 1, "these errors", "this error")}, or press N to exit.")
            While True
                Dim key = Console.ReadKey
                If key.Key = ConsoleKey.Y Then
                    Console.WriteLine()
                    For Each lament As Lamentation In CompilerErrors
                        Console.WriteLine($"{lament.ErrorCode}: {lament.Message}")
                    Next
                    Exit While
                ElseIf key.Key = ConsoleKey.N Then
                    End
                Else
                    Console.SetCursorPosition(0, Console.CursorTop)
                    Continue While
                End If
            End While
            Console.WriteLine("####################")
            Console.WriteLine("Execution failed. Press any key to exit.")
        Else
            Console.WriteLine($"{CompilerErrors.Count} compiler {If(CompilerErrors.Count > 1, "errors were", "error was")} found.")
            Console.WriteLine()
            For Each lament As Lamentation In CompilerErrors
                Console.WriteLine($"{lament.ErrorCode}: {lament.Message}")
            Next
            Console.WriteLine("Preprocessing failed; no changes are to be made to your Lilian code. Over to you, Lilian.")
        End If
    End Sub
End Module
Imports System.IO
Imports System.Xml
Imports System.Xml.Schema
Imports System.Xml.Serialization
Imports System.Text.RegularExpressions

Partial Public Module Interpreter
    REM Schema
    ' 
    Friend Sub Diversion(Line As String)
        If Not String.IsNullOrEmpty(Line) OrElse Not String.IsNullOrWhiteSpace(Line) Then
            For Each Feature As String In FeatureConstants
                If Regex.IsMatch(Line, Feature) Then
                    Select Case Array.IndexOf(FeatureConstants, Feature)
                        Case 0
                    End Select
                    Exit For
                Else
                    If Array.IndexOf(FeatureConstants, Feature) <> FeatureConstants.Length - 1 Then Continue For Else Throw New Lamentation(1, Line)
                End If
            Next
        End If
    End Sub

    Public Sub RegisterToken()

    End Sub


    Public Class Statement
        Implements IXmlSerializable

        Public Sub ReadXml(reader As XmlReader) Implements IXmlSerializable.ReadXml
            Throw New NotImplementedException()
        End Sub

        Public Sub WriteXml(writer As XmlWriter) Implements IXmlSerializable.WriteXml
            Throw New NotImplementedException()
        End Sub

        Public Function GetSchema() As XmlSchema Implements IXmlSerializable.GetSchema
            Throw New NotImplementedException()
        End Function
    End Class
End Module
#Const OrbPonderingTime = False
#Const VERBOSE = False

Imports System.Text.RegularExpressions

Partial Public Module Interpreter

    ''' <summary>
    ''' An interface for declaring this object to be contextualisable.
    ''' </summary>
    Public Interface IContextualisable
    End Interface

    ''' <summary>
    ''' An interface for declaring this object to be manipulable.
    ''' </summary>
    Public Interface IManipulable
    End Interface

    ''' <summary>
    ''' An object in code.
    ''' </summary>
    Public Structure FELObject
        Implements IManipulable, IEquatable(Of FELObject)

        ''' <summary>
        ''' 
        ''' </summary>
        ''' <param name="nm"></param>
        Public Sub New(nm As String)
            Name = nm
        End Sub

        ''' <summary>
        ''' 
        ''' </summary>
        ''' <param name="nm"></param>
        ''' <param name="val"></param>
        Public Sub New(nm As String, val As Object)
            Name = nm
            Value = val
        End Sub

        ''' <summary>
        ''' 
        ''' </summary>
        ''' <returns></returns>
        Public ReadOnly Property Name As String

        ''' <summary>
        ''' 
        ''' </summary>
        ''' <returns></returns>
        Public Property Value As Object

        ''' <summary>
        ''' 
        ''' </summary>
        ''' <param name="other"></param>
        ''' <returns></returns>
        Public Overloads Function Equals(other As FELObject) As Boolean Implements IEquatable(Of FELObject).Equals
            If Name = other.Name Then Return True Else Return False
        End Function

        Public Shared Operator =(obj1 As FELObject, obj2 As FELObject) As Boolean
            If obj1.Name = obj2.Name Then Return True Else Return False
        End Operator

        Public Shared Operator <>(obj1 As FELObject, obj2 As FELObject) As Boolean
            If obj1.Name <> obj2.Name Then Return True Else Return False
        End Operator

        ''' <summary>
        ''' 
        ''' </summary>
        ''' <returns></returns>
        Public Overrides Function ToString() As String
            Return Value.ToString()
        End Function

    End Structure

    Public Class FELObjectType
        Implements IManipulable

        Public Sub New(nm As String)
            Name = nm
            Contents = New List(Of IManipulable)
        End Sub

        Public Sub New(nm As String, ParamArray cont() As IManipulable)
            Name = nm
            Contents = New List(Of IManipulable)(cont)
        End Sub

        Public ReadOnly Property Name As String
        Public ReadOnly Property Contents As List(Of IManipulable)
    End Class

    Public Structure Action
        Implements IContextualisable

        Public Sub New(activity As WhatToDo)
            Act = activity
            WorkingValue = Nothing
            AssignmentValue = Nothing
            AssignmentType = Nothing
            RightAssignmentValue = Nothing
            OperationType = Nothing
        End Sub

        Public Sub New(activity As WhatToDo, val As Object)
            Act = activity
            WorkingValue = val
            AssignmentValue = Nothing
            AssignmentType = Nothing
            RightAssignmentValue = Nothing
            OperationType = Nothing
        End Sub

        Public Sub New(activity As WhatToDo, name As String, val As Object)
            Act = activity
            WorkingValue = name
            AssignmentValue = val
            AssignmentType = Nothing
            RightAssignmentValue = Nothing
            OperationType = Nothing
        End Sub

        Public Sub New(activity As WhatToDo, val As Object, assgn As Object, type As Operation)
            Act = activity
            WorkingValue = val
            AssignmentValue = assgn
            AssignmentType = type
            RightAssignmentValue = Nothing
            OperationType = 0
        End Sub

        Public Sub New(activity As WhatToDo, val As Object, assgn1 As Object, assgn2 As Object, type As Operation, optype As Operation)
            Act = activity
            WorkingValue = val
            AssignmentValue = assgn1
            AssignmentType = type
            RightAssignmentValue = assgn2
            OperationType = optype
        End Sub

        Public ReadOnly Property Act As WhatToDo

        Public Property WorkingValue As Object

        Public Property AssignmentValue As Object

        Public Property RightAssignmentValue As Object

        Public ReadOnly Property AssignmentType As Operation

        Public ReadOnly Property OperationType As Operation


        Public Enum WhatToDo As Byte
            NoOperation = 0
            Print = 1
            Assign = 2
            Define = 3
        End Enum

        Public Enum Operation As SByte
            [Nothing] = -1
            Assignment
            Addition
            Subtraction
            Multiplication
            Division
            Exponentation
            Modulo
            LeftShift
            RightShift
            [And]
            [Or]
            [Xor]
            Concatenation
            ProveThat
            ProveThatGreaterThan
            ProveThatLessThan
            ProveThatNot
            ProveThatGreaterOr
            ProveThatLessOr
            [Not]
            [AndAlso]
            [OrElse]
            PatternMatches
            TypeMatches
            TypeDoesNotMatch
        End Enum
    End Structure

    Public Class Context
        Implements IEnumerable, IContextualisable

        Friend ToDoList(0) As IContextualisable

        Public ReadOnly Property Count As Integer
            Get
                Return amount
            End Get
        End Property

        Friend amount As Integer

        Public Sub New(ParamArray actArray() As IContextualisable)
            ToDoList = New IContextualisable(actArray.Length - 1) {}

            If actArray.Length > ToDoList.Length Then Throw New Lamentation("bruh how the fuck", 10)

            'Dim i
            For i As Integer = 0 To actArray.Length - 1
                ToDoList(i) = actArray(i)
            Next

            amount = actArray.Length
        End Sub

        Public Sub Append(ParamArray actArray() As IContextualisable)
            If actArray.Length = 0 Then Exit Sub

            ' If actArray.Length + Count > ToDoList.Length Then Throw New Lamentation("bruh how the fuck", 10)

            ReDim Preserve ToDoList(Count + actArray.Length)

            For i As Integer = Count To (Count + actArray.Length) - 1
                ToDoList(i) = actArray(i - Count)
            Next

            amount += actArray.Length
        End Sub

        Public Sub RemoveAt(index As Integer)
            ToDoList(index) = Nothing
            amount -= 1
        End Sub

        Public Sub Clear()
            ToDoList = New IContextualisable(0) {}
            amount = 0
        End Sub

        Public Function GetEnumerator() As IEnumerator Implements IEnumerable.GetEnumerator
            Return New Contextualisation(ToDoList, Count)
        End Function
    End Class

    Public Class Contextualisation
        Implements IEnumerator

        Public ActionListing() As IContextualisable
        Dim Position As Integer = -1
        Dim Count As Integer

        Public Sub New(list() As IContextualisable, cnt As Integer)
            ActionListing = list
            Count = cnt
        End Sub

        Public ReadOnly Property Current As Object Implements IEnumerator.Current
            Get
                Try
                    Return ActionListing(Position)
                Catch ex As IndexOutOfRangeException
                    Throw New Lamentation("how in the fuck", 10)
                End Try
            End Get
        End Property

        Public Sub Reset() Implements IEnumerator.Reset
            Position = -1
        End Sub

        Public Function MoveNext() As Boolean Implements IEnumerator.MoveNext
            Position += 1
            Return (Position < Count)
        End Function
    End Class


    Public Sub Curse(act As IContextualisable)
        If TypeOf act Is Action Then
            Dim activite As Action = act
            With activite
                Select Case .Act
                    Case 0
                        Exit Sub
                    Case 1
                        Console.WriteLine(If(.WorkingValue, "This value is empty."))
                    Case 2
                        Dim Habilitated As FELObject = MotherStack.Find(Function(thing As FELObject) thing.Name = .WorkingValue)
                        Habilitated.Value = .AssignmentValue
                        MotherStack(MotherStack.FindIndex(Function(thing As FELObject) thing.Name = .WorkingValue)) = Habilitated
                    Case 3
                        Dim Habilitated As FELObject = MotherStack.Find(Function(thing As FELObject) thing = activite.WorkingValue)
                        Dim Whatever = Nothing
                        If TypeOf .AssignmentValue Is Long Then
                            If .RightAssignmentValue IsNot Nothing Then
                                If TypeOf .RightAssignmentValue Is Long Then
                                    Select Case .OperationType
                                        Case 1
                                            Whatever = .AssignmentValue + .RightAssignmentValue
                                        Case 2
                                            Whatever = .AssignmentValue - .RightAssignmentValue
                                        Case 3
                                            Whatever = .AssignmentValue * .RightAssignmentValue
                                        Case 4
                                            Whatever = .AssignmentValue / .RightAssignmentValue
                                        Case 5
                                            Whatever = Math.Pow(.AssignmentValue, .RightAssignmentValue)
                                        Case 6
                                            Whatever = .AssignmentValue Mod .RightAssignmentValue
                                        Case 7
                                            Whatever = .AssignmentValue << .RightAssignmentValue
                                        Case 8
                                            Whatever = .AssignmentValue >> .RightAssignmentValue
                                        Case 9
                                            Whatever = .AssignmentValue And .RightAssignmentValue
                                        Case 10
                                            Whatever = .AssignmentValue Or .RightAssignmentValue
                                        Case 11
                                            Whatever = .AssignmentValue Xor .RightAssignmentValue
                                        Case 12
                                            Whatever = .AssignmentValue & .RightAssignmentValue
                                        Case 13
                                            Whatever = .AssignmentValue = .RightAssignmentValue
                                        Case 14
                                            Whatever = .AssignmentValue > .RightAssignmentValue
                                        Case 15
                                            Whatever = .AssignmentValue < .RightAssignmentValue
                                        Case 16
                                            Whatever = .AssignmentValue <> .RightAssignmentValue
                                        Case 17
                                            Whatever = .AssignmentValue >= .RightAssignmentValue
                                        Case 18
                                            Whatever = .AssignmentValue <= .RightAssignmentValue
                                        Case Else
                                            Throw New Lamentation("bru", 1443)
                                    End Select
                                ElseIf TypeOf .RightAssignmentValue Is String Then
                                    Select Case .OperationType
                                        Case 12
                                            Whatever = .AssignmentValue & .RightAssignmentValue
                                        Case Else
                                            Throw New Lamentation("bru", 1443)
                                    End Select
                                End If
                            Else Throw New Lamentation("BSGFSGS", 1351) : End If
                        ElseIf TypeOf .AssignmentValue Is Boolean Then
                            If .RightAssignmentValue IsNot Nothing Then
                                If TypeOf .RightAssignmentValue Is Boolean Then
                                    Select Case .OperationType
                                        Case 9, 20
                                            Whatever = .AssignmentValue And .RightAssignmentValue
                                        Case 10, 21
                                            Whatever = .AssignmentValue Or .RightAssignmentValue
                                        Case 11
                                            Whatever = .AssignmentValue Xor .RightAssignmentValue
#If VERBOSE Then
                                        Case 20
                                            Whatever = .AssignmentValue AndAlso .RightAssignmentValue
                                        Case 21
                                            Whatever = .AssignmentValue OrElse .RightAssignmentValue
#End If
                                    End Select
                                End If
                            End If
                        ElseIf TypeOf .AssignmentValue Is String Then
                            If .RightAssignmentValue IsNot Nothing Then
                                If TypeOf .RightAssignmentValue Is String Then
                                    Select Case .OperationType
                                        Case 12
                                            Whatever = .AssignmentValue & .RightAssignmentValue
                                        Case 22
                                            Whatever = Regex.IsMatch(.AssignmentValue, .RightAssignmentValue)
                                        Case Else
                                            Throw New Lamentation("bru", 1443)
                                    End Select
                                Else
                                    If .OperationType = 12 Then Whatever = .AssignmentValue & .RightAssignmentValue.ToString() Else Throw New Lamentation("bruh", 6363)
                                End If
                            End If
                        End If
                        If TypeOf Habilitated.Value Is Long Then
                            If TypeOf Whatever Is Long Then
                                Select Case .AssignmentType

#If Not OrbPonderingTime Then
                                    Case 0
                                        Habilitated.Value = Whatever
                                    Case 1
                                        Habilitated.Value += Whatever
                                    Case 2
                                        Habilitated.Value -= Whatever
                                    Case 3
                                        Habilitated.Value *= Whatever
                                    Case 4
                                        Habilitated.Value /= Whatever
                                    Case 5
                                        Habilitated.Value = Math.Pow(Habilitated.Value, Whatever)
                                    Case 6
                                        Habilitated.Value = Habilitated.Value Mod Whatever
                                    Case 7
                                        Habilitated.Value <<= Whatever
                                    Case 8
                                        Habilitated.Value >>= Whatever
                                    Case 9
                                        Habilitated.Value = Habilitated.Value And Whatever
                                    Case 10
                                        Habilitated.Value = Habilitated.Value Or Whatever
                                    Case 11
                                        Habilitated.Value = Habilitated.Value Xor Whatever
                                    Case Else
                                        Throw New Lamentation("bsdfsdufuisduifgsuidfg", 1354)

#Else
                        Case Else
                            Console.WriteLine(.AssignmentType)
                            Console.WriteLine(.OperationType)
                            Console.WriteLine(.AssignmentValue.GetType().ToString() & ", " & activite.AssignmentValue.ToString())
                            Console.WriteLine(.RightAssignmentValue.GetType().ToString() & ", " & activite.RightAssignmentValue.ToString())
#End If
                                End Select
                            Else Throw New Lamentation("sdfsdf", 1243) : End If
                        ElseIf TypeOf Habilitated.Value Is String Then
                            Select Case .AssignmentType
                                Case 0
                                    Habilitated.Value = Whatever.ToString()
                                Case 12
                                    Habilitated.Value &= Whatever.ToString()
                                Case Else
                                    Throw New Lamentation("ouguofdgdfg", 1238)
                            End Select
                        Else
                            Habilitated.Value = Whatever
                            'Else Throw New Lamentation("sdfsdf", 1243) : End If
                        End If
                        MotherStack(MotherStack.IndexOf(activite.WorkingValue)) = Habilitated
                    Case Else
                        Throw New Lamentation("how the fucl", 42)
                End Select
            End With
        ElseIf TypeOf act Is Context Then
            Dim todo As Context = act
            For Each thing As IContextualisable In todo
                Curse(thing)
            Next
        End If
    End Sub

End Module